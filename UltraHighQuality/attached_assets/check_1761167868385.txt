const express = require('express');
const multer = require('multer');
const crypto = require('crypto');
const http = require('http');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIO(server);

const PORT = process.env.PORT || 3000;

// In-memory storage
const scripts = new Map();
let activeUsers = 0;

// Middleware
app.use(express.json());
app.use(express.static('public'));

// Socket.IO for active users
io.on('connection', (socket) => {
  activeUsers++;
  io.emit('userCount', activeUsers);
  console.log(`User connected. Active users: ${activeUsers}`);

  socket.on('disconnect', () => {
    activeUsers--;
    io.emit('userCount', activeUsers);
    console.log(`User disconnected. Active users: ${activeUsers}`);
  });
});

// File upload
const storage = multer.memoryStorage();
const upload = multer({ storage: storage, limits: { fileSize: 5 * 1024 * 1024 } });

// FIXED Lua Obfuscator - Actually works!
class AdvancedLuaObfuscator {
  constructor(code, level) {
    this.originalCode = code;
    this.code = code;
    this.level = level;
    this.varMap = new Map();
  }

  generateVarName(prefix = '_') {
    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const nums = '0123456789';
    let name = prefix;
    for (let i = 0; i < 8; i++) {
      if (i === 0) {
        name += chars[Math.floor(Math.random() * chars.length)];
      } else {
        name += (Math.random() > 0.5 ? chars : nums)[Math.floor(Math.random() * (Math.random() > 0.5 ? chars.length : nums.length))];
      }
    }
    return name;
  }

  // Working string encryption
  encryptString(str) {
    if (this.level === 'basic') return `"${str}"`;
    
    // Character array method (always works)
    const bytes = str.split('').map(c => c.charCodeAt(0)).join(',');
    return `(function()local s={${bytes}}local r=""for i=1,#s do r=r..string.char(s[i])end return r end)()`;
  }

  // Rename variables
  renameIdentifiers() {
    const localPattern = /local\s+([a-zA-Z_][a-zA-Z0-9_]*)/g;
    let match;
    const identifiers = new Set();
    
    while ((match = localPattern.exec(this.originalCode)) !== null) {
      const varName = match[1];
      // Don't rename common Lua keywords or builtins
      if (!['self', 'true', 'false', 'nil'].includes(varName)) {
        identifiers.add(varName);
      }
    }
    
    identifiers.forEach(name => {
      if (!this.varMap.has(name)) {
        this.varMap.set(name, this.generateVarName());
      }
    });
    
    // Replace in order of length (longest first) to avoid partial replacements
    const sortedVars = Array.from(this.varMap.entries()).sort((a, b) => b[0].length - a[0].length);
    
    sortedVars.forEach(([oldName, newName]) => {
      const regex = new RegExp(`\\b${oldName}\\b`, 'g');
      this.code = this.code.replace(regex, newName);
    });
  }

  // Obfuscate strings safely
  obfuscateStrings() {
    if (this.level === 'basic') return;
    
    // Only obfuscate strings longer than 3 characters
    this.code = this.code.replace(/"([^"]{4,})"/g, (match, str) => {
      return this.encryptString(str);
    });
    
    this.code = this.code.replace(/'([^']{4,})'/g, (match, str) => {
      return this.encryptString(str);
    });
  }

  // Number virtualization (safe)
  virtualizeNumbers() {
    if (this.level !== 'extreme') return;
    
    this.code = this.code.replace(/\b(\d+)\b/g, (match, num) => {
      const n = parseInt(num);
      if (n < 10 || n > 10000) return match;
      
      // Simple safe operations
      const methods = [
        `(${Math.floor(n / 2)}+${n - Math.floor(n / 2)})`,
        `(${n}+0)`,
        `(${n}-0)`,
      ];
      
      return methods[Math.floor(Math.random() * methods.length)];
    });
  }

  // Add junk code (safe)
  addJunkCode() {
    if (this.level !== 'extreme') return;
    
    const junk = [];
    for (let i = 0; i < 5; i++) {
      const varName = this.generateVarName('_j');
      junk.push(`local ${varName}=${Math.floor(Math.random() * 1000)};`);
    }
    
    this.code = junk.join('') + this.code;
  }

  // Simple VM wrapper (working)
  wrapInVM() {
    if (this.level === 'basic') return;
    
    const vmVar = this.generateVarName('_v');
    const funcVar = this.generateVarName('_f');
    
    this.code = `local ${vmVar}=function()${this.code} end;local ${funcVar}=${vmVar}();return ${funcVar}`;
  }

  // Main obfuscation method
  obfuscate() {
    console.log(`Obfuscating with level: ${this.level}`);
    
    try {
      // Apply layers in safe order
      this.renameIdentifiers();
      this.obfuscateStrings();
      this.virtualizeNumbers();
      this.addJunkCode();
      
      // Don't wrap in VM if code is very short
      if (this.code.length > 50) {
        this.wrapInVM();
      }
      
      const header = `--[[\n  SOF (Safety of Obfuscation)\n  Level: ${this.level}\n  Timestamp: ${new Date().toISOString()}\n]]\n\n`;
      
      return header + this.code;
    } catch (error) {
      console.error('Obfuscation error:', error);
      // Return original code if obfuscation fails
      return `-- Obfuscation failed, returning original\n${this.originalCode}`;
    }
  }
}

// Generate random key
function generateKey(length = 32) {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  let key = '';
  for (let i = 0; i < length; i++) {
    key += chars[Math.floor(Math.random() * chars.length)];
  }
  return key;
}

// API Endpoints

// Obfuscate endpoint
app.post('/api/obfuscate', upload.single('file'), (req, res) => {
  try {
    let code;
    
    if (req.file) {
      code = req.file.buffer.toString('utf-8');
    } else if (req.body.code) {
      code = req.body.code;
    } else {
      return res.status(400).json({ error: 'No code provided' });
    }
    
    if (code.length < 5) {
      return res.status(400).json({ error: 'Code is too short' });
    }
    
    const level = req.body.level || 'basic';
    
    const obfuscator = new AdvancedLuaObfuscator(code, level);
    const obfuscated = obfuscator.obfuscate();
    
    const id = crypto.randomBytes(16).toString('hex');
    
    scripts.set(id, {
      code: obfuscated,
      created: new Date(),
      size: obfuscated.length,
      level: level,
      accessCount: 0,
      type: 'obfuscated'
    });
    
    const host = req.get('host');
    const protocol = req.get('x-forwarded-proto') || req.protocol;
    const loadstringUrl = `${protocol}://${host}/script/${id}`;
    const loadstringCode = `loadstring(game:HttpGet("${loadstringUrl}"))()`;
    
    res.json({
      success: true,
      id: id,
      loadstring: loadstringCode,
      url: loadstringUrl,
      size: obfuscated.length,
      level: level
    });
  } catch (error) {
    console.error('Obfuscation error:', error);
    res.status(500).json({ error: 'Obfuscation failed: ' + error.message });
  }
});

// Generate key endpoint
app.post('/api/generate-key', (req, res) => {
  try {
    const length = parseInt(req.body.length) || 32;
    const format = req.body.format || 'alphanumeric';
    
    if (length < 8 || length > 128) {
      return res.status(400).json({ error: 'Length must be between 8 and 128' });
    }
    
    let key;
    if (format === 'hex') {
      key = crypto.randomBytes(Math.floor(length / 2)).toString('hex');
    } else if (format === 'uuid') {
      key = crypto.randomUUID();
    } else {
      key = generateKey(length);
    }
    
    res.json({
      success: true,
      key: key,
      length: key.length,
      format: format
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Script serving endpoint
app.get('/script/:id', (req, res) => {
  const id = req.params.id;
  const script = scripts.get(id);
  
  if (!script) {
    return res.status(404).send('-- Script not found');
  }
  
  const userAgent = (req.get('User-Agent') || '').toLowerCase();
  const accept = (req.get('Accept') || '').toLowerCase();
  const referer = req.get('Referer') || '';
  const secFetchDest = req.get('Sec-Fetch-Dest') || '';
  const secFetchMode = req.get('Sec-Fetch-Mode') || '';
  const cfConnectingIp = req.get('CF-Connecting-IP') || req.ip;
  
  console.log(`Script access: ${id} | IP: ${cfConnectingIp} | UA: ${userAgent.substring(0, 50)}`);
  
  const browserPatterns = /mozilla|chrome|safari|firefox|edge|opera|msie|trident/i;
  const toolPatterns = /curl|wget|python|requests|postman|insomnia|httpie|axios/i;
  const robloxPattern = /roblox/i;
  
  const isBrowser = browserPatterns.test(userAgent) && !robloxPattern.test(userAgent);
  const isTool = toolPatterns.test(userAgent);
  const hasHtmlAccept = accept.includes('text/html');
  const hasReferer = referer.length > 0;
  const isDocument = secFetchDest === 'document';
  const isNavigate = secFetchMode === 'navigate';
  
  const isBlocked = isBrowser || isTool || hasHtmlAccept || hasReferer || isDocument || isNavigate;
  
  if (isBlocked) {
    return res.send(`
      <!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>SOF - Access Denied</title>
        <style>
          * { margin: 0; padding: 0; box-sizing: border-box; }
          body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            color: #e2e8f0;
            padding: 20px;
          }
          .container { max-width: 600px; text-align: center; }
          .badge {
            display: inline-block;
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
            color: #fca5a5;
            padding: 10px 24px;
            border-radius: 25px;
            font-weight: 600;
            margin-bottom: 40px;
            font-size: 14px;
          }
          h1 {
            font-size: 56px;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
          }
          .divider {
            width: 60px;
            height: 3px;
            background: linear-gradient(90deg, #60a5fa, #a78bfa);
            margin: 15px auto;
          }
          h2 {
            font-size: 20px;
            margin-bottom: 50px;
            color: #94a3b8;
          }
          .message-box {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 40px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="badge">ACCESS DENIED</div>
          <h1>SOF</h1>
          <div class="divider"></div>
          <h2>Safety of Obfuscation</h2>
          <div class="message-box">
            <p>This script has been protected by SOF.</p>
          </div>
        </div>
      </body>
      </html>
    `);
  }
  
  script.accessCount++;
  res.setHeader('Content-Type', 'text/plain');
  res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.send(script.code);
});

// Get scripts
app.get('/api/scripts', (req, res) => {
  const scriptList = Array.from(scripts.entries()).map(([id, data]) => ({
    id,
    size: data.size,
    created: data.created,
    level: data.level || 'N/A',
    type: data.type || 'unknown',
    accessCount: data.accessCount
  }));
  
  res.json(scriptList);
});

// Delete script
app.delete('/api/scripts/:id', (req, res) => {
  const id = req.params.id;
  if (scripts.has(id)) {
    scripts.delete(id);
    res.json({ success: true });
  } else {
    res.status(404).json({ error: 'Script not found' });
  }
});

// Get active users count
app.get('/api/active-users', (req, res) => {
  res.json({ count: activeUsers });
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'ok', scripts: scripts.size, activeUsers: activeUsers });
});

server.listen(PORT, () => {
  console.log(`🛡️  SOF Server running on port ${PORT}`);
  console.log(`📦 Scripts in memory: ${scripts.size}`);
  console.log(`✅ Fixed obfuscation - scripts now work!`);
  console.log(`👥 Active users tracking enabled`);
});